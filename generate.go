package main

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"aletheia.icu/broccoli/fs"
)

type Generator struct {
	pkg *Package

	inputFiles  []string // list of source dirs
	outputFile  string   // <input[0]>.gen.go
	outputVar   string   // embedded variable
	includeGlob string   // files to be included
	excludeGlob string   // files to be excluded
	quality     int      // compression level (1-11)
}

const template = `// Code generated by broccoli at %v. DO NOT EDIT.
package %s

import "aletheia.icu/broccoli/fs"

func init() {
	%s := fs.New([]byte("%s"))
}
`

func (g *Generator) generate() {
	var (
		files []*fs.File
		state = map[string]bool{}
	)

	for _, input := range g.inputFiles {
		info, err := os.Stat(input)
		if err != nil {
			log.Fatalf("file or directory %s not found\n", input)
		}

		var f *fs.File
		if info.IsDir() {
			err = filepath.Walk(input, func(path string, _ os.FileInfo, _ error) error {
				f, err := fs.NewFile(path)
				if err != nil {
					return err
				}

				if _, ok := state[path]; ok {
					log.Fatalf("duplicate path in ithe input: %s\n", path)
				}
				state[path] = true
				files = append(files, f)
				return nil
			})
		} else {
			f, err = fs.NewFile(input)

			if _, ok := state[input]; ok {
				log.Fatalf("duplicate path in the input: %s\n", input)
			}
			state[input] = true
			files = append(files, f)
		}

		if err != nil {
			log.Fatalf("cannot open file or directory: %s\n", input)
		}
	}

	payload, err := fs.Pack(files, g.quality)
	if err != nil {
		log.Fatal("could not compress the input:", err)
	}

	code := fmt.Sprintf(template,
		time.Now(), g.pkg.name, g.outputVar, payload)

	err = ioutil.WriteFile(g.outputFile, []byte(code), 0644)
	if err != nil {
		log.Fatalf("could not write to %s: %v\n", g.outputFile, err)
	}
}

// Package holds information about a Go package
type Package struct {
	dir      string
	name     string
	defs     map[*ast.Ident]types.Object
	typesPkg *types.Package
}

func (g *Generator) parsePackage() {
	pkg, err := build.Default.ImportDir(".", 0)
	if err != nil {
		log.Fatalln("cannot parse package:", err)
	}

	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)
	names = append(names, pkg.SFiles...)

	var astFiles []*ast.File
	g.pkg = new(Package)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("parsing package: %s: %s\n", name, err)
		}
		astFiles = append(astFiles, parsedFile)
	}
	if len(astFiles) == 0 {
		log.Fatalln("no buildable Go files")
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.dir = "."

	// Type check the package.
	g.pkg.check(fs, astFiles)
}

// check type-checks the package. The package must be OK to proceed.
func (pkg *Package) check(fs *token.FileSet, astFiles []*ast.File) {
	pkg.defs = make(map[*ast.Ident]types.Object)
	config := types.Config{Importer: defaultImporter(), FakeImportC: true}
	info := &types.Info{
		Defs: pkg.defs,
	}
	typesPkg, err := config.Check(pkg.dir, fs, astFiles, info)
	if err != nil {
		log.Fatalf("checking package: %s\n", err)
	}

	pkg.typesPkg = typesPkg
}

func defaultImporter() types.Importer {
	return importer.For("source", nil)
}
